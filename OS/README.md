# OS 운영체제

> 면접에서 나올법한 질문들

* 프로세스란?
  > 프로세스는 메모리에 올라와있는 프로그램의 인스턴스를 말합니다. 
  > 즉, 컴퓨터에 연속적으로 실행이 진행중인 프로그램.
  > 운영체제로부터 할당받은 작업의 단위
  > ex) icon을 클릭할때 메모리에 올리고 CPU가 실행하는 상태
* 프로세스의 구조
   	- Stack: - 함수가 호출될때 생성되는 지역변수와 매개변수들이 저장이 됨. 함수 호출이 완료되면 LIFO로 제거됨
   		- 스택은 메모리가 한정되어 있기 때문에 너무 큰 메모리는 할당 할 수 없음(stack overflow).
		- 힙은 데이터 크기를 모를때 스택과 힙은 같은 메모리 공간을 사용함.
	- Heap: - 사용자가 직접 관리하는 메모리 영역. 동적으로 메모리를 할당하고 해제
		- 메모리 해제 반드시 해줘야하는데 ARC 덕분에 안해도 됨.
		- 클래스, 클로져와 같은 Reference Type이 힙에 자동으로 저장됨
		
	- Data: - 전역 변수들, 상수들이 저장되는 영역 
		- read-write
		- 프로그램 시작과 동시에 할당되고 프로그램이 종료되면 해제
	- Text / Code: 실행할 코드(기계어) 가 저장되는 영역..read-only
* 프로세스의 상태
	> New: 프로세스 생성중
	> Running: 실행
	> Waiting: 이벤트(I/O완료) 가 일어나기를 기다림
	> Ready: CPU 할당을 기다림
	> Terminated: 종료
* 스레드란?
	> 스레드는 프로세스의 실행 흐름을 나타내는 단위입니다. 경량화된 프로세스
	> 프로세스 내의 자원을 서로 공유 할 수 있습니다.
	> 스레드는 프로세스 내에서 각각 Stack/Register/Counter 만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
	> 일부의 프로세스가 효율적으로 실행이 되기 위해 여러개의 스레드를 사용 할 수 있습니다
* 스택을 스레드마다 독립적으로 할당하는 이유?
	> 각각의 스레드가 독립적인 작업을 수행해야되기 때문에 각각 고유의 스택을 갖고있는것으로 알고있습니다. 스레드마다 함수호출을 하기 때문에
* 멀티스레딩과 멀티프로세싱의 차이
* CPU의 역할
* 커널이란?
  > 메모리에 상주하는 운영체제의 부분. 운영체제의 모든 부분들이 동시에 메모리에 올라가있다면 메모리가 너무 차지됨. 그래서 중요한 부분들만 메모리에 올려놓는것.
* 인터럽트란?
  > CPU에게 하고있는 일을 중단하고 다른 일을 하도록 시키는 신호입니다.
  > 예를 들면 CPU 가 어떠한 작업을 수행하고 있는 도중에 인터럽트 신호가 오면, 하고있던 일을 멈추고 인터럽트 신호를 먼저 처리합니다.
  > 인터럽트가 한 번에 여러개가 오는 경우가 있을 수 밖에 없기 때문에, 인터럽트에 우선순위를 매겨서, 우선순위가 높은 인터럽트부터 차례대로 처리를 해줍니다.
* DMA란
  > 디바이스를 이용할때 메모리에 자주 접근을 하는데, 이걸 CPU가 중간에서 중재를 해줍니다. 디바이스가 CPU 한테 데이터를 요청하면, CPU는 메모리에 가서 해당 데이터를 가져오고 그걸 디바이스한테 전달하는, 그런 방식으로 데이터가 이동이되는데, CPU가 여러 가지 일을 한번에 많이 처리 하다보니까 매번 그렇게 데이터를 메모리에서 꺼내오는게 오래걸릴 수 있습니다. 그래서 Direct Memory Access 를 통해, 디바이스가 CPU를 거치지않고 바로 메모리에 가서 데이터를 가져오는걸 말합니다.
* 프로세스 제어 블럭이란(PCB)?
	> 프로세스가 인터럽트에 의해서 중간에 끊기는 상황이 있을 수 있는데, 그럴때 프로세스의 진행상황을 어딘가에 저장해야되는데 그걸 저장하는 곳이 프로세스 제어 블럭입니다.
	> 프로세스가 생성될때 함께 생성이되고, 프로세스마다 각자 고유의 process control block을 갖고있다고 볼 수 있습니다.
	> 프로세스 상태, CPU 스케쥴링 정보 등을 저장

* 스레드를 사용해본 경험?
* 프로세스 스케쥴링이란?
	> CPU가 다음에 어느 프로세스를 실행할지 결정하는 것
	> 프로세스 큐로 스케쥴링을 진행
		> Job Queue: 현재 시스템에서 돌고있는 프로세스들의 집합 
		> Ready queue : Ready 상태의 프로세스들이 CPU의 선택을 받기위해 줄을 서있는 것 (연결리스트 형태)
		> Device queue:  하드디스크의 접근을 위해 프로세스들이 기다리는 줄

* 스케쥴러의 종류
	> Short-term(단기): 다음 프로세스를 선택
	> Long-term(장기): 다음 ready queue에 넣을 프로세스를 선택
	> Mid-term(중기): 여유 공간 부족시, 디스크로 옮김. .멀티프로그래밍의 수를 줄일때
* 스케쥴링 알고리즘
	> CPU의 이용률을 높이는 방법
	> 선점형 방식과 비선점형 방식으로 나눌 수 있는데, 선점형 방식은 우선순위가 높은 프로세스가 도달하면 그 즉시 그 프로세스에게 CPU를 할당. 빼앗아오는것
	> 비선점형 방식은 Ready Queue의 맨 앞에 그 프로세스를 등록. Starvation과 CPU를 사용못하는 프로세스를 CPU가 무한 대기하는 상태가 있을 수 있음. 오래 기다렸을 경우 우선순위를 높이는 Aging을 통해 해결 가능. 다른 프로세스 영향 못끼침 
* 스케쥴링 알고리즘 종류
	> - 선입선처리 (First Come First Served) : 먼저 온 녀석이 먼저 스케줄링을 받음. 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐.. 문제점은 먼저 들어온 애가 CPU를 오래잡고있으면 뒤에 애들이 대기 시간이 길어진다 
	> - 최단작업우선 (Short Job First) : 실행시간이 짧은 프로세스 부터 먼저 할당 해주는 것. 문제는 다음 CPU버스트 시간을 알기 힘들다. 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당. 이렇게 되면 수행시간이 긴 프로세스는 영원히 할당받지 못할 수도 있음(Starvation)
	> - 최소 잔여 시간 우선 (Short Remaining Time) : 현재 프로세스의 수행시간이 끝나는 시간보다 나중에 오는 프로세스의 수행시간 완료 시간이 더 짧다면, 그 즉시 그 프로세스에게 CPU를 할당. 선점형 스케줄링. Starvation과 CPU 수행 시간을 측정할 수 없다는 문제가 있음 
	> - Round Robin : 현대적인 CPU 스케줄링으로, 선입선처리의 문제점을 개선한 방법. 각 프로세스에게 CPU 할당 시간을 지정해준다. 할당량만큼 실행하고 다시 Ready 큐 맨 뒤로 들어감.
각 프로세스는 동일한 CPU 할당 시간을 갖게 됨. 할당시간 만료시 ready queue 맨 뒤에 가서 줄섬. CPU의 사용시간이 제각각일 때 효율적. 반응 속도가 빨라지며, 공정한 스케줄링. 주의할 점은 할당하는 시간(time quantum)이 너무 길다면 FCFS와 다를게 없음. 너무 작다면 잦은 컨텍스트 스위칭이 발생.

* Context Switching(문맥 교환) 이란?
	> - 프로세스의 전환을 의미함. 전환이 일어날때 기존 프로세스의 상태를 저장하고 새 프로세스의 상태를 읽어오는것
	> - 순수 Overhead: 프로세스의 진행은 전혀 안이루어짐. (바뀌기만 함) 
	> - PCB가 복잡해질수록 context switch도 복잡해진다
	> - HW 지원이 있으면 개선 될 수 있다(CPU내 레지스터가 다수 세트 있을때)
	- 자주 일어날수록 좋을까??
		> 장단점이 있다. 자주 일어나면 프로세스들이 마치 동시에 실행되는것 처럼 자연스럽다. 하지만 단점으로는, overhead가 높다. CPU의 성능을 계속 거기에만 사용해야함. 즉, 프로세스가 느려짐(진행이 안됨)

* 멀티프로세싱
	> 하나의 CPU가 여러개의 프로세스를 마치 동시에 일어나는것 처럼 처리하는 것
	- 장단점?
		> 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없습니다.
		- 장점: 여러개의 프로세스 중에 하나가 죽어도, 딱히 영향이 없습니다
		- 단점: - 프로그램이 프로세스 사이를 왔다갔다하는게 문맥 전환(Context Switching)인데, -> 오버헤드가 높다
		       
* 멀티스레딩
	> 하나의 프로세스 안에서 여러개의 스레드를 사용하여 작업을 처리하는것
	> 하나의 프로세스가 다수의 작업을 동시에 수행
	- 장점: - 시스템의 성능을 최대로 활용 할 수 있다
		- 스레드들은 프로세스의 자원을 공유하기 때문에 프로세스 간의 통신(IPC) 보다 훨씬 효율적이고 빠르다
		- 프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어들게 된다.
		- 응답성, 자원 공유, 
		- 경제성: 프로세스에 비해 생성이 가볍고 문맥교환도 쉽다
		- Scalablilty: 멀티프로세서 시스템에서 더 좋은 성능을 보인다

* 동기와 비동기의 차이
* 동기와 비동기의 장단점?


</br>
